<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <h1>Function</h1>
    <h2>함수작성</h2>
    <script>
        // function 이건 함수다

        // 함수선언식 -> 호이스팅이된다.()
        function foo() {

        }

        // 함수표현식 -> 호이스팅x
        var bar = function () { };
        bar();//함수표현식의 함수는 반드시 작성된 이후에 호출해야 한다.

        // 즉시실행함수(IIFE)
        // - IIFE(Immediately Invoked Function Expression)
        // - 1회용 함수를 작성하고 싶을때 사용
        // - (함수)();
        (function () {
            console.log('hello js')
        })(); //한번 사용후 끝나면 더이상 이걸 불러올 방법이 없음 
        // 익명함수로 사용됨

        (function () {
            console.log('bye js')
        }());//위와 같이 한번 사용후 끝나면 더이상 이걸 불러올 방법이 없음 

        (function (name) {
            console.log('hello ' + name)
        })('철수');
        //이게 다 함수를 값으로서 사용하기 때문에(js는)
    </script>

    <h2>매개변수 | 매개인자</h2>
    <!-- //매개변수 : 값을 전달받기 위한 변수 -->
    <!-- //매개인자 : 실제 전달하는 값으로서 -->
    <input type="button" value="확인" onclick="test1(1,2,3);">
    <input type="button" value="확인" onclick="test2();">

    <script>
        // 매개변수(parameter) : 함수선언시 매개인자가 담길 공간
        // 매개이자(argument) : 함수호출시 전달할 값
        // 자바스크립트에서 매개변수와 매개인자의 개수가 달라도
        // 문제되지 않는다.
        function test1(x) { //다시한번 확이하기
            console.log("x = ", x);

            // 모든 함수는 묵시적으로 arguments(매개이자들)배열을 가지고 있다.
            console.log(arguments);
        }

        //실습(2번째 확인버튼)
        function test2() {
            // 매개인자의 합을 출력하는 add메서드 작성
            add(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); // 55출력
            add(12.34, 45.67);//58.01 출력
            add('a', 'b', 'c', 'd');//"abcd"출력
        }
        function add() {
            var sum = typeof (arguments[0]) == 'number' ? 0 : "";// 혹은 이즈난(이즈넌?)
            for (var i = 0; i < arguments.length; i++) {
                sum += arguments[i];
            }
            if (typeof (arguments[0]) == 'number') {
                sum = Math.floor(sum * 100) / 100;
            }
            console.log(sum);
        }
    </script>

    <h2>함수 특징</h2>
    <input type="button" value="return value" onclick="test3();">
    <input type="button" value="중첩 함수" onclick="test4(10, 5);">

    <script>
        // 함수의 return구문이 없거나, return 뒤쪽에
        // 반환할 값이 없는 경우 ...
        function test3() {
            var k = koo();
            console.log(k);
        }

        function koo() {
            return 100;
            //return; 자동으로 리턴함
        }

        // a^2 + b^2 = c^2;
        function test4(a, b) {
            var c;

            var power = function (n) {
                return n ** 2;
            }

            //**은 지수여산자(제곱)
            // c = Math.sqrt(a ** 2 + b ** 2);//피타고라스의 정의
            c = Math.sqrt(power(a) + power(b));
            console.log(c);
        }
    </script>

    <h2>고급 함수</h2>
    <!-- 함수를 값으로써 쓸수있는 함수 -->
    <input type="button" value="매개인자" onclick="test5();">
    <input type="button" value="리턴값" onclick="test6();">
    <input type="button" value="999" onclick="">

    <script>
        /*
            자바스크립트에서 함수는 "값"으로 취급된다.
            1. 변수에 대입할 수 있고
            2. 함수의 매개인자로 전달될 수 있고
            3. 리턴값으로 사용될 수 있다.
        */
        function test5(){
            // 함수를 값으로써 매개인자로 전달하기.
            exec(function(str){
                console.log("hello "+str);
            });
        }

        // function exec(fn) {//펑션 타입을 받겠다
        var names = ['html','css','javascript','jquery'];
        function exec(fn){
            for(var i =0; i<names.length; i++){
                fn(names[i]);
            }
        }

        function test6() {
            // 하수를 리턴값으로 사용하기
            var hello = returnFunction('hello');
            hello('js');

            returnFunction("Goodbye")("js");
        }

        function returnFunction(say) {
            return function (name) { // 리턴 함수
                // var say = say; //눈에는 안보이지만 있는 거다라고 생각하기
                console.log(say + " " + name);
            }
        }
    </script>
    <h2>Closure</h2>
    <input type="button" value="globalCounter" onclick="test7();">
    <input type="button" value="ClosureCounter1" onclick="test8();">
    <input type="button" value="ClosureCounter2" onclick="test9();">
    <script>
        var cnt = 0; // 전역변수(Globar/script scope)
        function test7() {
            // local scope(함수 내부의 스코프)
            // debugger;
            var a = 0;
            console.log("global : "+ ++cnt);
        }
        /*
            클로져(Closure)
             - 중첩함수에서 하위 함수가, 상위함수의 변수를 참조할 때 생겨나는
               스코프
             - 하위함수에서 상위함수의 변수값을 참조하는 경우 ,하위함수의
               closure스코프에 변수값을 추가한다.
             - 클로져 인해, Stack메모리에서 상위함수의 메모리가 제거되더라도
               상위함수의 변수를 그대로 가져다 사용할 수 있다.
        */
        function funcY(){
            var num = 100;
            function funcZ(){
                // debugger
                console.log("num=", num);
            }
            return funcZ;
        }
        const myFn = funcY();
        // myFn();

        function makeClosureCounter(){
            var cnt = 0;
            return function(){
                console.log('cloureScope : ' + ++cnt);
            }
        }

        var test8 = makeClosureCounter();
        var test9 = makeClosureCounter();
        // 각클로져 영역은 서로 겹치지 않고 서로 함수마다 고유하게 존재함


    </script>
</body>

</html>